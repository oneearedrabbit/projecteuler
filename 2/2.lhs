Problem 2
---------

Source: http://projecteuler.net/index.php?section=problems&id=2

Each new term in the Fibonacci sequence is generated by adding the previous
two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.

Input: None

Output: 42

Solution
--------

That's a classic algorithm and the academic definition of the Fibonacci
numbers is following:

> fib' 0 = 1
> fib' 1 = 1
> fib' n = fib' (n-1) + fib' (n-2)

This definition is elegant, but highly inefficient since it results in to a
tree recursion with a complexity O(2^n). Furthermore, if we decide to
generate the Fibonacci sequence whose values do not exceed four million the
complexity will be sum(n=1..4000000) O(2^n). In other words, we can't solve
this task with this elegant code.

I think it's preferable to think of any math sequence in Haskell as an
infinite sequence. Haskell doesn't calculate an element of the list
until its needed. If we need to calculate seq(n) we just take nth
element from that sequence, or in Haskell seq !! n.

And here comes the true force of the functional programming. Let's assume
we have two infinite Fibonacci sequences:
   [1, 2, 3, 5, 8, ...]
[1, 2, 3, 5, 8, ...]

The only thing we need to do is to sum 1st and 2nd sequences with a
shift. And that shift is a tail of the 2nd sequence. Look:
   [1, 2, 3,  5,  8, ...]
+  [2, 3, 5,  8, 13, ...]
=  [3, 5, 8, 13, 21, ...]

So an infinite sequence of the Fibonacci numbers can be calculated by
prepending [1, 1] to the result above.

There is a function that combines two lists using the given operator
-- zipWith. Therefore, everything we need to do is just to reunion
these pieces. This is a canonical (however, again not the fastest)
implementation:

> fib = 1 : 2 : zipWith (+) fib (tail fib)

or

> fib'' = 1 : 1 : [ a+b | a <- fib | b <- tail fib ];

Now, we can calculate sum of even-valued numbers of the Fibonacci
sequence whose values do not exceed four million.

> problem_2 = sum $ filter even $ takeWhile (<=4000000) fib

> main = print problem_2

Performance
-----------

real	0m0.638s
user	0m0.552s
sys	0m0.080s
